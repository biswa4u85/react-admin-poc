{"ast":null,"code":"var _jsxFileName = \"/Users/sunita/Sites/Erptech/react-admin-poc/src/@crema/utility/RouteGenerator.js\",\n    _s = $RefreshSig$();\n\nimport { Navigate, useRoutes } from 'react-router-dom';\nimport { authRole, RoutePermittedRole } from '../../shared/constants/AppEnums';\n/**\r\n * @param {Object} structure - The passed object that defines the routes.\r\n * @param {boolean} structure.isAuthenticated - [Required] in order to differentiate between LoggedIn/Loggedout users\r\n * @param {string} structure.userRole - [Optional] in order to differentiate between admin and normal users\r\n * @param {object} [structure.anonymousStructure] - it's an object that has only [ routes ] array, [ these routes available for All personas ]\r\n * @param {object} [structure.authorizedStructure] - it's an object that has [ fallbackPath: {string}, routes: {array} ], fallbackPath: is used for redirect when a logged [in] user tried to access unAuthorized route, routes: only The Logged [in] Routes Available\r\n * @param {object} [structure.unAuthorizedStructure] - it's an object that has [ fallbackPath: {string}, routes: {array} ], fallbackPath: is used for redirect when a logged [out] user tried to access route that requires [Authorization] , routes: only The Logged [out] Routes Available\r\n * @param {component} [structure.component fallbackComponent] - in order to redirect in all cases if the route doesn't match.\r\n * @param {unAuthorizedComponent} [structure.unAuthorizedComponent] - in order to show not permitted route.\r\n * @returns {Array}\r\n */\n\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nconst generateRoutes = structure => {\n  _s();\n\n  const {\n    isAuthenticated = false,\n    anonymousStructure = {},\n    authorizedStructure = {},\n    unAuthorizedStructure = {},\n    userRole = authRole.user\n  } = structure || {};\n  const dynamicRoutes = [];\n\n  if (anonymousStructure) {\n    dynamicRoutes.push(...routesGenerator(isAuthenticated, anonymousStructure, 'anonymous'));\n  }\n\n  if (authorizedStructure) {\n    dynamicRoutes.push(...routesGenerator(isAuthenticated, authorizedStructure, 'authorized', isAuthenticated ? userRole : null));\n  }\n\n  if (unAuthorizedStructure) {\n    dynamicRoutes.push(...routesGenerator(isAuthenticated, unAuthorizedStructure, 'unAuthorized'));\n  }\n\n  return useRoutes(dynamicRoutes);\n};\n/**\r\n * path: string\r\n * component: React.Component\r\n * routeProps: Object -----> To override route props\r\n * userRole: string -----> To override route props\r\n * redirectPath: String ----> To redirect to specific location\r\n * showRouteIf: to override when to show the component or when to [ Navigate ]\r\n */\n\n\n_s(generateRoutes, \"mNBMh7IZrKf5fDyw9x3t8azefmI=\", false, function () {\n  return [useRoutes];\n});\n\nconst routesGenerator = (isAuthenticated = false, routeSet = {}, type = 'anonymous', userRole) => {\n  const generatedRoutes = [];\n  const {\n    fallbackPath = ''\n  } = routeSet || {};\n  const isAnonymous = type === 'anonymous';\n  const isAuthorized = type === 'authorized';\n\n  if (routeSet === null || routeSet === void 0 ? void 0 : routeSet.routes) {\n    const routes = routeSet.routes;\n\n    if (Array.isArray(routes) && routes.length > 0) {\n      routes.forEach((route\n      /*index*/\n      ) => {\n        const {\n          path = '',\n          permittedRole = RoutePermittedRole.superadmin,\n          // routeProps = {},\n          redirectPath = '',\n          showRouteIf = true\n        } = route || {}; // Show Route only [ in The list ] if this prop is true\n\n        if (showRouteIf) {\n          // check the mandatory props for a routes\n          if (!path) {\n            console.log(`A [route] is skipped because one of the following, No valid [path] prop provided for the route`, isAuthenticated);\n          } else {\n            if (isAnonymous) {\n              return generatedRoutes.push(route);\n            }\n\n            if (isAuthorized) {\n              const renderCondition = isAuthorized ? isAuthenticated : !isAuthenticated;\n\n              if (Array.isArray(route.path)) {\n                route.path.map(path => {\n                  generatedRoutes.push(renderCondition ? userRole.indexOf(permittedRole) > -1 ? {\n                    element: route.element,\n                    path: path,\n                    permittedRole: route.permittedRole\n                  } : {\n                    path: path,\n                    element: routeSet.unAuthorizedComponent\n                  } : {\n                    path: path,\n                    element: /*#__PURE__*/_jsxDEV(Navigate, {\n                      to: redirectPath || fallbackPath,\n                      replace: true\n                    }, void 0, false, {\n                      fileName: _jsxFileName,\n                      lineNumber: 121,\n                      columnNumber: 27\n                    }, this)\n                  });\n                });\n              } else {\n                generatedRoutes.push(renderCondition ? userRole.indexOf(permittedRole) > -1 ? route : {\n                  path: route.path,\n                  element: routeSet.unAuthorizedComponent\n                } : {\n                  path: route.path,\n                  element: /*#__PURE__*/_jsxDEV(Navigate, {\n                    to: redirectPath || fallbackPath,\n                    replace: true\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 141,\n                    columnNumber: 25\n                  }, this)\n                });\n              }\n\n              return generatedRoutes;\n            }\n\n            const renderCondition = isAuthorized ? isAuthenticated : !isAuthenticated;\n\n            if (Array.isArray(route.path)) {\n              route.path.map(path => {\n                generatedRoutes.push(renderCondition ? {\n                  element: route.element,\n                  path: path,\n                  permittedRole: route.permittedRole\n                } : {\n                  path: path,\n                  element: /*#__PURE__*/_jsxDEV(Navigate, {\n                    to: redirectPath || fallbackPath,\n                    replace: true\n                  }, void 0, false, {\n                    fileName: _jsxFileName,\n                    lineNumber: 164,\n                    columnNumber: 25\n                  }, this)\n                });\n              });\n            } else {\n              generatedRoutes.push(renderCondition ? route : {\n                path: route.path,\n                element: /*#__PURE__*/_jsxDEV(Navigate, {\n                  to: redirectPath || fallbackPath,\n                  replace: true\n                }, void 0, false, {\n                  fileName: _jsxFileName,\n                  lineNumber: 176,\n                  columnNumber: 23\n                }, this)\n              });\n            }\n\n            return generatedRoutes;\n          }\n        }\n      });\n    }\n  } else {\n    console.log(`[routes] prop can't be found in ${type}Structure Object`);\n  }\n\n  return generatedRoutes;\n};\n\nexport default generateRoutes;","map":{"version":3,"sources":["/Users/sunita/Sites/Erptech/react-admin-poc/src/@crema/utility/RouteGenerator.js"],"names":["Navigate","useRoutes","authRole","RoutePermittedRole","generateRoutes","structure","isAuthenticated","anonymousStructure","authorizedStructure","unAuthorizedStructure","userRole","user","dynamicRoutes","push","routesGenerator","routeSet","type","generatedRoutes","fallbackPath","isAnonymous","isAuthorized","routes","Array","isArray","length","forEach","route","path","permittedRole","superadmin","redirectPath","showRouteIf","console","log","renderCondition","map","indexOf","element","unAuthorizedComponent"],"mappings":"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","sourcesContent":["import { Navigate, useRoutes } from 'react-router-dom';\r\nimport { authRole, RoutePermittedRole } from '../../shared/constants/AppEnums';\r\n\r\n/**\r\n * @param {Object} structure - The passed object that defines the routes.\r\n * @param {boolean} structure.isAuthenticated - [Required] in order to differentiate between LoggedIn/Loggedout users\r\n * @param {string} structure.userRole - [Optional] in order to differentiate between admin and normal users\r\n * @param {object} [structure.anonymousStructure] - it's an object that has only [ routes ] array, [ these routes available for All personas ]\r\n * @param {object} [structure.authorizedStructure] - it's an object that has [ fallbackPath: {string}, routes: {array} ], fallbackPath: is used for redirect when a logged [in] user tried to access unAuthorized route, routes: only The Logged [in] Routes Available\r\n * @param {object} [structure.unAuthorizedStructure] - it's an object that has [ fallbackPath: {string}, routes: {array} ], fallbackPath: is used for redirect when a logged [out] user tried to access route that requires [Authorization] , routes: only The Logged [out] Routes Available\r\n * @param {component} [structure.component fallbackComponent] - in order to redirect in all cases if the route doesn't match.\r\n * @param {unAuthorizedComponent} [structure.unAuthorizedComponent] - in order to show not permitted route.\r\n * @returns {Array}\r\n */\r\n\r\nconst generateRoutes = (structure) => {\r\n  const {\r\n    isAuthenticated = false,\r\n    anonymousStructure = {},\r\n    authorizedStructure = {},\r\n    unAuthorizedStructure = {},\r\n    userRole = authRole.user,\r\n  } = structure || {};\r\n\r\n  const dynamicRoutes = [];\r\n\r\n  if (anonymousStructure) {\r\n    dynamicRoutes.push(\r\n      ...routesGenerator(isAuthenticated, anonymousStructure, 'anonymous'),\r\n    );\r\n  }\r\n\r\n  if (authorizedStructure) {\r\n    dynamicRoutes.push(\r\n      ...routesGenerator(\r\n        isAuthenticated,\r\n        authorizedStructure,\r\n        'authorized',\r\n        isAuthenticated ? userRole : null,\r\n      ),\r\n    );\r\n  }\r\n\r\n  if (unAuthorizedStructure) {\r\n    dynamicRoutes.push(\r\n      ...routesGenerator(\r\n        isAuthenticated,\r\n        unAuthorizedStructure,\r\n        'unAuthorized',\r\n      ),\r\n    );\r\n  }\r\n  return useRoutes(dynamicRoutes);\r\n};\r\n\r\n/**\r\n * path: string\r\n * component: React.Component\r\n * routeProps: Object -----> To override route props\r\n * userRole: string -----> To override route props\r\n * redirectPath: String ----> To redirect to specific location\r\n * showRouteIf: to override when to show the component or when to [ Navigate ]\r\n */\r\nconst routesGenerator = (\r\n  isAuthenticated = false,\r\n  routeSet = {},\r\n  type = 'anonymous',\r\n  userRole,\r\n) => {\r\n  const generatedRoutes = [];\r\n  const { fallbackPath = '' } = routeSet || {};\r\n\r\n  const isAnonymous = type === 'anonymous';\r\n  const isAuthorized = type === 'authorized';\r\n\r\n  if (routeSet?.routes) {\r\n    const routes = routeSet.routes;\r\n    if (Array.isArray(routes) && routes.length > 0) {\r\n      routes.forEach((route /*index*/) => {\r\n        const {\r\n          path = '',\r\n          permittedRole = RoutePermittedRole.superadmin,\r\n          // routeProps = {},\r\n          redirectPath = '',\r\n          showRouteIf = true,\r\n        } = route || {};\r\n        // Show Route only [ in The list ] if this prop is true\r\n        if (showRouteIf) {\r\n          // check the mandatory props for a routes\r\n          if (!path) {\r\n            console.log(\r\n              `A [route] is skipped because one of the following, No valid [path] prop provided for the route`,\r\n              isAuthenticated,\r\n            );\r\n          } else {\r\n            if (isAnonymous) {\r\n              return generatedRoutes.push(route);\r\n            }\r\n            if (isAuthorized) {\r\n              const renderCondition = isAuthorized\r\n                ? isAuthenticated\r\n                : !isAuthenticated;\r\n\r\n              if (Array.isArray(route.path)) {\r\n                route.path.map((path) => {\r\n                  generatedRoutes.push(\r\n                    renderCondition\r\n                      ? userRole.indexOf(permittedRole) > -1\r\n                        ? {\r\n                          element: route.element,\r\n                          path: path,\r\n                          permittedRole: route.permittedRole,\r\n                        }\r\n                        : {\r\n                          path: path,\r\n                          element: routeSet.unAuthorizedComponent,\r\n                        }\r\n                      : {\r\n                        path: path,\r\n                        element: (\r\n                          <Navigate\r\n                            to={redirectPath || fallbackPath}\r\n                            replace\r\n                          />\r\n                        ),\r\n                      },\r\n                  );\r\n                });\r\n              } else {\r\n                generatedRoutes.push(\r\n                  renderCondition\r\n                    ? userRole.indexOf(permittedRole) > -1\r\n                      ? route\r\n                      : {\r\n                        path: route.path,\r\n                        element: routeSet.unAuthorizedComponent,\r\n                      }\r\n                    : {\r\n                      path: route.path,\r\n                      element: (\r\n                        <Navigate to={redirectPath || fallbackPath} replace />\r\n                      ),\r\n                    },\r\n                );\r\n              }\r\n\r\n              return generatedRoutes;\r\n            }\r\n            const renderCondition = isAuthorized\r\n              ? isAuthenticated\r\n              : !isAuthenticated;\r\n            if (Array.isArray(route.path)) {\r\n              route.path.map((path) => {\r\n                generatedRoutes.push(\r\n                  renderCondition\r\n                    ? {\r\n                      element: route.element,\r\n                      path: path,\r\n                      permittedRole: route.permittedRole,\r\n                    }\r\n                    : {\r\n                      path: path,\r\n                      element: (\r\n                        <Navigate to={redirectPath || fallbackPath} replace />\r\n                      ),\r\n                    },\r\n                );\r\n              });\r\n            } else {\r\n              generatedRoutes.push(\r\n                renderCondition\r\n                  ? route\r\n                  : {\r\n                    path: route.path,\r\n                    element: (\r\n                      <Navigate to={redirectPath || fallbackPath} replace />\r\n                    ),\r\n                  },\r\n              );\r\n            }\r\n\r\n            return generatedRoutes;\r\n          }\r\n        }\r\n      });\r\n    }\r\n  } else {\r\n    console.log(`[routes] prop can't be found in ${type}Structure Object`);\r\n  }\r\n  return generatedRoutes;\r\n};\r\n\r\nexport default generateRoutes;\r\n"]},"metadata":{},"sourceType":"module"}